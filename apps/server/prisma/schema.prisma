// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String             @id
  name                String
  email               String
  emailVerified       Boolean            @default(false)
  image               String?
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @default(now()) @updatedAt
  sessions            Session[]
  accounts            Account[]
  todos               Todo[]
  memberships         Membership[]
  institutesCreatedBy Institute[]        @relation("InstituteCreatedBy")
  personOnInstitutes  PersonOnInstitut[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

model Todo {
  id        String   @id @default(uuid())
  text      String
  completed Boolean  @default(false)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("todo")
}

enum EducationLevel {
  NONE
  ELEMENTARY_INCOMPLETE
  ELEMENTARY_COMPLETE
  HIGH_SCHOOL_INCOMPLETE
  HIGH_SCHOOL_COMPLETE
  TECHNICAL
  UNIVERSITY_INCOMPLETE
  UNIVERSITY_COMPLETE
  POSTGRAD
}

enum KinshipDegree {
  SPOUSE
  CHILD
  FATHER
  MOTHER
  SIBLING
  GRANDPARENT
  GRANDCHILD
  UNCLE_AUNT
  NEPHEW_NIECE
  COUSIN
  OTHER
}

enum MembershipRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

model Institute {
  id          String  @id @default(uuid())
  name        String
  slug        String  @unique
  description String?

  // (opcional) atalho pra quem criou, mas o "dono" oficial fica na Membership
  createdById String?
  createdBy   User?   @relation("InstituteCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)

  memberships        Membership[]
  personOnInstitutes PersonOnInstitut[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("institute")
}

model Membership {
  id String @id @default(uuid())

  userId      String
  instituteId String
  role        MembershipRole @default(MEMBER)

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  institute Institute @relation(fields: [instituteId], references: [id], onDelete: Cascade)

  joinedAt  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // um user só pode ter 1 membership por instituto
  @@unique([userId, instituteId])
  @@index([instituteId])
  @@index([userId])
  @@map("membership")
}

model Person {
  id          String   @id @default(uuid())
  fullName    String
  cpf         String   @unique // armazenar como string (com ou sem máscara)
  birthDate   DateTime
  phoneNumber String?

  fatherName String?
  motherName String?

  educationLevel EducationLevel?

  receivesBolsaFamilia Boolean @default(false)
  nis                  String? @unique // NIS / Cadastro Único (opcional mas único quando existir)

  // Relacionamentos
  address     Address?
  relatives   PersonRelative[]
  enrollments PersonCourse[]
  assistances PersonAssistance[]
  documents   PersonDocument[]

  personOnInstitutes PersonOnInstitut[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([fullName])
  @@map("person")
}

model PersonOnInstitut {
  id          String    @id @default(uuid())
  userId      String?
  user        User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  personId    String
  instituteId String
  person      Person    @relation(fields: [personId], references: [id], onDelete: Cascade)
  institute   Institute @relation(fields: [instituteId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("person_on_institut")
}

model Address {
  id String @id @default(uuid())

  cep          String
  neighborhood String
  street       String
  number       String
  complement   String?

  personId String @unique
  person   Person @relation(fields: [personId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("address")
}

model PersonRelative {
  id       String @id @default(uuid())
  personId String
  person   Person @relation(fields: [personId], references: [id], onDelete: Cascade)

  relativeName String
  degree       KinshipDegree
  degreeText   String? // se degree = OTHER, você pode preencher aqui (ex: "cunhado", "padrasto", etc)
  phoneNumber  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([personId])
  @@map("person_relative")
}

/// =======================
/// CURSOS + PARCEIROS
/// =======================

model CoursePartner {
  id          String  @id @default(uuid())
  name        String
  description String?

  courses Course[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name])
  @@map("course_partner")
}

model Course {
  id          String  @id @default(uuid())
  title       String
  description String?

  partnerId String
  partner   CoursePartner @relation(fields: [partnerId], references: [id], onDelete: Restrict)

  enrollments PersonCourse[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([partnerId])
  @@index([title])
  @@map("course")
}

// Tabela N:N (Pessoa <-> Curso) com metadados (status/datas)
model PersonCourse {
  id       String @id @default(uuid())
  personId String
  courseId String

  person Person @relation(fields: [personId], references: [id], onDelete: Cascade)
  course Course @relation(fields: [courseId], references: [id], onDelete: Restrict)

  enrolledAt  DateTime  @default(now())
  completedAt DateTime?
  notes       String?
  updatedAt   DateTime  @updatedAt

  @@unique([personId, courseId])
  @@index([courseId])
  @@map("person_course")
}

/// =======================
/// TIPOS DE AJUDA (auxílio transporte, cesta básica...)
/// =======================

model AssistanceType {
  id          String  @id @default(uuid())
  name        String  @unique
  description String?

  records PersonAssistance[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("assistance_type")
}

model PersonAssistance {
  id               String @id @default(uuid())
  personId         String
  assistanceTypeId String

  person         Person         @relation(fields: [personId], references: [id], onDelete: Cascade)
  assistanceType AssistanceType @relation(fields: [assistanceTypeId], references: [id], onDelete: Restrict)

  receivedAt DateTime @default(now())
  quantity   Int?
  valueCents Int? // se fizer sentido (ex: vale, cartão)
  notes      String?
  updatedAt  DateTime @updatedAt

  @@index([personId])
  @@index([assistanceTypeId])
  @@map("person_assistance")
}

/// =======================
/// DOCUMENTOS / FOTO DA CARTEIRA
/// =======================

enum PersonDocumentType {
  WALLET_PHOTO // “foto da carteira”
  OTHER
}

model PersonDocument {
  id       String @id @default(uuid())
  personId String
  person   Person @relation(fields: [personId], references: [id], onDelete: Cascade)

  type PersonDocumentType @default(WALLET_PHOTO)

  // você pode salvar URL (S3, Cloudflare R2, etc) ou caminho interno
  fileUrl  String
  fileName String?
  mimeType String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([personId])
  @@map("person_document")
}
